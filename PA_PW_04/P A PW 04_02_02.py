"""
2). Написать два алгоритма нахождения i-го по счёту простого числа.
Функция нахождения простого числа должна принимать на вход натуральное и возвращать соответствующее простое число.
Проанализировать скорость и сложность алгоритмов.

Первый — с помощью алгоритма «Решето Эратосфена».
Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков. Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.

Второй — без использования «Решета Эратосфена».
Примечание. Вспомните классический способ проверки числа на простоту.


Решето Эратосфена
Это алгоритм поиска простых чисел. Для этого нужно:

Записать все числа от 1 до n (например, записываются все числа от 1 до 100, если нужны все простые числа между ними);
Вычеркнуть все числа, которые делятся на 2 (кроме 2);
Вычеркнуть все числа, которые делятся на 3 (кроме 3);
И так далее по порядку со всеми невычеркнутыми числами до числа n (после 3 это 5, 7, 11, 13, 17 и т. д.).
Те числа, которые не будут вычеркнуты в конце этого процесса, являются простыми.

"""

import timeit
import cProfile

def simp_numb(n):

    #usr_num = int(input('Введите позицию простого числа ->  '))

    usr_num = n

    count = 1
    number = 1
    simp_n_arr = [2]

    if usr_num == 1:
        return 2

    while count != usr_num:
        number += 2
        #print(f'{simp_n_arr= }')
        for num in simp_n_arr:
            # print(f'{num= }')
            # print(f'{number= }')
            if number % num == 0:
                break
        else:
            count += 1
            simp_n_arr.append(number)

    return number

#print(simp_numb(int(input('Введите число: '))))


N = 1
meas_n = 12  # колличество измерений
step_N = 2  # шаг изменения кол-ва N


for n in range(1, meas_n + 1):
    t = timeit.timeit('simp_numb(N)', number=1000, globals=globals())
    print(f'{n} при N = {N:6.0f} время выполнения {t} ')
    N = N * step_N


cProfile.run('simp_numb(10000)')

"""
Выводы по решению без Решета:

1 при N =      1 время выполнения 0.00026640900000000217 
2 при N =      2 время выполнения 0.0008347180000000051 
3 при N =      4 время выполнения 0.0015800620000000001 
4 при N =      8 время выполнения 0.004175727000000004 
5 при N =     16 время выполнения 0.016272292 
6 при N =     32 время выполнения 0.049265453 
7 при N =     64 время выполнения 0.15280723 
8 при N =    128 время выполнения 0.6033016680000001 
9 при N =    256 время выполнения 2.2187298350000004 
10 при N =    512 время выполнения 9.123862364999999 
11 при N =   1024 время выполнения 36.015825428 
12 при N =   2048 время выполнения 144.531877709 

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    3.639    3.639 <string>:1(<module>)
        1    3.635    3.635    3.639    3.639 P A PW 04_02_02.py:27(simp_numb)
        1    0.000    0.000    3.639    3.639 {built-in method builtins.exec}
     9999    0.003    0.000    0.003    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}


Оба теста показывают что данная программа работает несколько быстрее чем программа "Решето"

"""











"""
if usr_num == 1:
    answ = 2
elif usr_num == 2:
    answ = 3
    
    
while count != usr_num:
    start_n += 1
    for i in range(2, start_n + 1):
        if start_n % i == 0:
            continue
    else:
        count += 1
        answ = start_n
"""
