"""
2). Написать два алгоритма нахождения i-го по счёту простого числа.
Функция нахождения простого числа должна принимать на вход натуральное и возвращать соответствующее простое число.
Проанализировать скорость и сложность алгоритмов.

Первый — с помощью алгоритма «Решето Эратосфена».
Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков. Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.

Второй — без использования «Решета Эратосфена».
Примечание. Вспомните классический способ проверки числа на простоту.


Решето Эратосфена
Это алгоритм поиска простых чисел. Для этого нужно:

Записать все числа от 1 до n (например, записываются все числа от 1 до 100, если нужны все простые числа между ними);
Вычеркнуть все числа, которые делятся на 2 (кроме 2);
Вычеркнуть все числа, которые делятся на 3 (кроме 3);
И так далее по порядку со всеми невычеркнутыми числами до числа n (после 3 это 5, 7, 11, 13, 17 и т. д.).
Те числа, которые не будут вычеркнуты в конце этого процесса, являются простыми.

"""

"""
Для проподавателя. К сожалению я непонял как сделать задачу через решето Эратосфена... поэтому с копипастил...
Позор на мою голову... Надеюсь просмотр 5-го вебинара поможет мне в понимани данного алгоритма.

"""

# C Решетом Эратосфена

import timeit
import cProfile

def eratosthenes_sieve(n):
    count = 1
    start = 3
    end = 4 * n

    sieve = [i for i in range(start, end) if i % 2 != 0]
    #print(f'{sieve= }')
    prime = [2]

    if n == 1:
        return 2

    while count < n:

        for i in range(len(sieve)):

            if sieve[i] != 0:
                count += 1

                if count == n:
                    return sieve[i]

                j = i + sieve[i]

                while j < len(sieve):
                    sieve[j] = 0
                    j += sieve[i]

        prime.extend([i for i in sieve if i != 0])

        start, end = end, end + 2 * n
        sieve = [i for i in range(start, end) if i % 2 != 0]

        for i in range(len(sieve)):

            for num in prime:

                if sieve[i] % num == 0:
                    sieve[i] = 0
                    break


#print(eratosthenes_sieve(int(input('Введите позицию простого числа -> '))))

N = 1
meas_n = 12  # колличество измерений
step_N = 2  # шаг изменения кол-ва N


for n in range(1, meas_n + 1):
    t = timeit.timeit('eratosthenes_sieve(N)', number=1000, globals=globals())
    print(f'{n} при N = {N:6.0f} время выполнения {t} ')
    N = N * step_N


cProfile.run('eratosthenes_sieve(10000)')

"""

Выводы по Эратосфену:

1 при N =      1 время выполнения 0.0009497480000000003 
2 при N =      2 время выполнения 0.0018896610000000008 
3 при N =      4 время выполнения 0.0040970450000000005 
4 при N =      8 время выполнения 0.008311257000000002 
5 при N =     16 время выполнения 0.014055074 
6 при N =     32 время выполнения 0.077598391 
7 при N =     64 время выполнения 0.197807156 
8 при N =    128 время выполнения 0.554196146 
9 при N =    256 время выполнения 3.4620829889999998 
10 при N =    512 время выполнения 10.934359198 
11 при N =   1024 время выполнения 35.174319172 
12 при N =   2048 время выполнения 210.08771977100002

С увеличением числа N время выполнения начинает расти сильнее чем увеличение числа N, увеличивается не линейно.
Замечена странность в некоторых моментах рост времени = х2 затем х6 потом х2,5 полочается некая полка в графике,
Возможно это связано с работой моего ПК...

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    5.611    5.611 <string>:1(<module>)
        1    5.594    5.594    5.611    5.611 P A PW 04_02_01.py:35(eratosthenes_sieve)
        1    0.003    0.003    0.003    0.003 P A PW 04_02_01.py:40(<listcomp>)
        4    0.002    0.000    0.002    0.000 P A PW 04_02_01.py:63(<listcomp>)
        4    0.006    0.002    0.006    0.002 P A PW 04_02_01.py:66(<listcomp>)
        1    0.000    0.000    5.611    5.611 {built-in method builtins.exec}
    48769    0.005    0.000    0.005    0.000 {built-in method builtins.len}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
        4    0.000    0.000    0.000    0.000 {method 'extend' of 'list' objects}

Судя по данным основные затраты идут на саму ф-цию eratosthenes_sieve, а в нутрии её, я так понял, основные затраты 
это built-in method builtins.exec что это за метод я не знаю...

"""