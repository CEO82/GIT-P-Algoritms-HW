"""

1). Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего
задания первых трех уроков.
Примечание. Идеальным решением будет:
● выбрать хорошую задачу, которую имеет смысл оценивать (укажите в комментарии какую задачу вы взяли),
● написать 3 варианта кода (один у вас уже есть),
● проанализировать 3 варианта и выбрать оптимальный,
● результаты анализа вставить в виде комментариев в файл с кодом
(не забудьте указать, для каких N вы проводили замеры),
● написать общий вывод: какой из трёх вариантов лучше и почему.

Начальное задание:
В массиве случайных целых чисел поменять местами минимальный и максимальный элементы.

"""

import random
import timeit
import cProfile

print('Третий вариант кода')

def time_research_2(size, min_itm, max_itm):
    SIZE = size
    MIN_ITEM = min_itm
    MAX_ITEM = max_itm
    #array = [random.randint(MIN_ITEM, MAX_ITEM) for i in range(SIZE)]
    array = []
    array_2 = []
    array_3 = []
    for n in range(size):
        array.append(random.randint(MIN_ITEM, MAX_ITEM))
        for w in array:
            array_2.append(w + random.randint(MIN_ITEM, MAX_ITEM))
            # for r in array_2:
            #     array_2.append(r * random.randint(MIN_ITEM, MAX_ITEM))

    #print(f'Исходный массив:\n{array}')

    max_n = MIN_ITEM
    max_n_i = 0
    min_n = MAX_ITEM
    min_n_i = 0
    #count = 0

    for p, i in enumerate(array, 0):
        if max_n < i:
            max_n = i
            max_n_i = p
        if min_n > i:
            min_n = i
            min_n_i = p


    array[max_n_i], array[min_n_i] = array[min_n_i], array[max_n_i]

    return array

resault = time_research_2(10, -1000, 1000)

print(f'Изменный массив:\n{resault}')

N = 10 # кол-во элементов в массиве
M = -1000
K = 1000


meas_n = 7  # колличество измерений
step_N = 2  # шаг изменения кол-ва N
step_M_K = 1
# step_K = 1


for n in range(1, meas_n + 1):
    t = timeit.timeit('time_research_2(N, M, K)', number=1000, globals=globals())
    print(f'{n} при N = {N:6.0f} время выполнения {t} ')
    N = N * step_N
    M = M * step_M_K
    K = K * step_M_K

cProfile.run('time_research_2(100000000, M, K)')


"""
3-й вариант выводы:

step_N = 10
1 при N =     10 время выполнения 0.101678158 
2 при N =    100 время выполнения 7.0090824849999995 
3 при N =   1000 время выполнения 701.917202241 
после 6-ти часов результат так и не появился...

step_N = 2

1 при N =     10 время выполнения 0.10459845899999999 
2 при N =     20 время выполнения 0.316573706 
3 при N =     40 время выполнения 1.171056812 
4 при N =     80 время выполнения 4.438403186 
5 при N =    160 время выполнения 17.571661998

step_N = 3

1 при N =     10 время выполнения 0.09194481700000001 
2 при N =     30 время выполнения 0.683094023 
3 при N =     90 время выполнения 5.895800521 
4 при N =    270 время выполнения 53.287427564 
5 при N =    810 время выполнения 480.19565551100004 

step_N = 2

1 при N =     10 время выполнения 0.10376201099999999 
2 при N =     20 время выполнения 0.31918098100000003 
3 при N =     40 время выполнения 1.191770043 
4 при N =     80 время выполнения 4.498811395000001 
5 при N =    160 время выполнения 18.048255324 
6 при N =    320 время выполнения 76.37682583 
7 при N =    640 время выполнения 294.721318374 

В данном случае зависимость перестала быть линейной и становится больше похожей на экспоненту, 
при этом время выполнения катастрафически увеличилось в сравнении с предыдущими вариантами.


при размере массива 10000

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    3.649    3.649  184.003  184.003 <string>:1(<module>)
        1   44.428   44.428  180.354  180.354 P A PW 04_01_03.py:24(time_research_2)
 50015000   47.972    0.000   98.523    0.000 random.py:200(randrange)
 50015000   27.044    0.000  125.568    0.000 random.py:244(randint)
 50015000   34.273    0.000   50.552    0.000 random.py:250(_randbelow_with_getrandbits)
        1    0.002    0.002  184.005  184.005 {built-in method builtins.exec}
 50015000   10.359    0.000   10.359    0.000 {method 'append' of 'list' objects}
 50015000    8.136    0.000    8.136    0.000 {method 'bit_length' of 'int' objects}
        1    0.001    0.001    0.001    0.001 {method 'disable' of '_lsprof.Profiler' objects}
 51191588    8.143    0.000    8.143    0.000 {method 'getrandbits' of '_random.Random' objects}
 
 В данном случае пришлось снизить размер массива т.к. время выполнения привысило 6 часов...
 Основные потери:
 
 генерация случайных чисел,
 

"""